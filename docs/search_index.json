[["index.html", "R and RStudio for STAT216 Chapter 1 About 1.1 Organization 1.2 Getting started 1.3 Code in this book 1.4 Help 1.5 Debugging 1.6 Other resources", " R and RStudio for STAT216 Charles Katerba Last update: 2022-09-14 Chapter 1 About This book is intended to be a quick and dirty introduction to R (a statistical programming language) and RStudio (an integrated development environment, or IDE, for R) for students in the introductory statistics class at Flathead Valley Community College. This book aims to introduce you to all of the features youll need to use in R to be successful in the course. Moreover, we hope that it will help you develop the tools you need to use R in your future endeavors. This book is by no means a complete guide to everything one can do in R, but the aim is to cut down on content and theory in the name of practicality. This class will provide many students with their first interaction with computer programming. The coding required is not extensive and the coding-based activities are heavily scaffolded. The point of including R in this course is not to introduce another layer of difficulty; the opposite is true in fact! The goal is to give you a glimpse at how programming can make your life easier, at least when it comes to statistics and data science. In the process, you will hopefully add another useful and practical tool to your tool belt. Computers are not exiting our lives any time soon and being somewhat familiar with a little programming will only be an advantage. Some might say such familiarity will become essential. 1.1 Organization The chapters of this book will be organized to follow the flow of STAT216 so that reading the book sequentially teaches you the tools as you need them in class. This book will almost certainly be a work in progress, so if theres something that youd like to see or if you think something is missing, dont hesitate to reach out to the author (or your instructor if they are different people). 1.2 Getting started The programming language R is somewhat old, appearing first in 1993. That said, it is still quite useful and will remain so for a long time coming since it is an open-source programming language and software environment. This means that the development and maintenance of the language and software are in the hands of all users, not just a small, select group of developers. Fear not! You will not have to do any developing. For our purposes, the open-source nature of R implies that the community of users will continue to grow the features and power of the language to meet the needs of the times. There are two mains ways to use R: through a cloud computing service or through an installation directly to your computer. The easiest way to start is through a cloud computing service. In both cases, we recommend you use the IDE RStudio as it makes using R more intuitive and straightforward. Below we describe how to use RStudio on the cloud and on your own computer. RStudio (which will rebrand as Posit in October 2022) hosts its own cloud computing service called RStudio Cloud. To get started: Click the previous link to access their website. Create a new account, for free. Your free account gives 25 project hours per month. This should be enough for your work in STAT216, but theres a chance youll need more. There is a small fee in this case. Click Start a new project in the top right corner of your browser. This will open an RStudio session for you. Change the name of your project to something evocative to tell your future self what you were working on. Some ideas: STAT216 HW, STAT216 Activities, etc. You are now ready to rip! You can also download a desktop version of RStudio. Accessing R in this way is slightly more involved, but offers more flexibility and no computational limitations. It is also free. To install R to your own computer: First, you must install R. This link takes you to CRAN, the Comprehensive R Archive Network, where you can download the latest version of R. Be sure to select the download appropriate to your operating system and follow the instructions provided at the link above. Next, download and install RStudio Desktop following the directions at the link. Again, be sure to select the download appropriate to your operating sytem. You can now open RStudio by finding the application on your computer. You, too, are now ready to rip! No matter what version of RStudio you are using, you should now see a window that looks something like this on your computer. An RStudio terminal. Before proceeding, notice that your RStudio session has 3 windows open. The console: this is the most interactive window in your session. You can run quick calculations here. For example, type 2 + 2 then hit enter. Files/plots window: The files tab shows all of the files present in your current working directory. We dont need to talk much about file management here and will cover it as needed in the future. When you make quick plots, they will appear under the plot tab. For example, evaluating plot(rnorm(10), rnorm(10)) in the console will produce a plot similar to the one above in the Plots panel. This little bit of code generates 2 collections of 10 random numbers and makes a scatter plot of the results. Environment window: This window displays the names of the objects you have stored in your computers memory. As an example, if you evaluate x &lt;- rnorm(10), you will see the value x appear in the Environment tab. It is good to check the values you have stored when youre running into problems with your code. At this point, you can skim the rest of this chapter or move on to RStudio basics. 1.3 Code in this book You should be able to copy and paste all code chunks in this book into your own RStudio terminal and reproduce the results you see in the book. All data used in this book will be sourced from base R, other commonly used packages, or appropriate links will be given for downloaded data sets. The author will endeavor to be clear about what packages are loaded and where data sets are coming from throughout the book. 1.4 Help There are many avenues for finding help using R. Your instructor, the STEM tutoring center, and the internet are great places to start. For the latter, you have to carefully phrase what youre asking, but if you do so, you can usually find great results with some clear examples. R also has a lot of built in help documentation. You can access this documentation using a ? before the name of the function/object that youre intereted in. For example, R has a function called prop.test(...) that well learn how to use in this class. To see Rs documententation for prop.test(...), simply run ?prop.test in the console. The examples are usually helpful, but sometimes can create more confusion. In any case, this is a great place to start when you feel confused about a particular function or object. If you bring up the documentation for an in-built data set, it will describe what the variables of that data set are. For instance, try running ?mtcars in the console 1.5 Debugging In this class, you will very likely come to a point where some code youve written will not run. This experience can be very frustrating. Remember, it happens to everyone and it frustrates everyone. Hadley Wickham provides a a detailed guide on how to debug code in this book Advanced R, but here is my take with a few additions. Double and triple check your syntax. New coders are often stymied by small syntax mistakes. For instance, if you want to use a function called f in R, but you type F instead, the machine wont do the right thing. Similarly, be careful about commas; for example, elements of lists need to be separated by commas and they can be easy to forget. There are a too many syntax errors one can make to list here. Search the internet for the error codes youre seeing. You can simply copy and paste them into your web browser. Most likely someone before you has made the same mistake and asked the same question. Figure out exactly where the error is. This is harder than it seems like it should be sometimes. In short pieces of code it is usually easy to identify, but when you become more advanced and write longer code the problem can get tricky. Reach out to your instructor and/or the STEM tutoring center at FVCC. These people are invaluable resources. Be sure to not only share the error code, but the entire chunk of code that you think is problematic. Even better, share all of your code. The website CrossValidated is a stack exchange where users can ask and answers questions about statistics, especially R coding. You may be able to get questions answered here, but be warned: the community is very picky about how you ask questions and about the type of questions you ask. 1.6 Other resources As mentioned above, these notes are only going to give you a brief glimpse of R and RStudio. The resources linked below will either provide a much more in-depth look at R and its applications or provide a very quick summary of certain packages and/or features. RStudio cheatsheets. These are invaluable as they provide a lot of information in a small amount of space. A list of helpful R functions. Thomas Scofield made a super consice list of commonly used base R functions and provided examples on how to use them. R for Data Science. As the title suggests, this book focuses more on data science than on statistics, so it spends more time on data visualization, programming, data wrangling, and modeling. Advanced R. This book goes into the more nitty gritty details of programming in R. In writing this book the author has referenced many of the works above along with a collection of other resources. See the bibliography for a somewhat complete list. "],["rstudio-basics.html", "Chapter 2 RStudio basics 2.1 A big calculator 2.2 Naming things 2.3 Lists and vectors 2.4 Packages 2.5 Data frames and tibbles 2.6 R Markdown documents", " Chapter 2 RStudio basics At this point you should have an operational RStudio terminal at your disposal. If not, go back to Getting started. This chapter will focus some of the most basic tools and skills youll need to successfully use RStudio. Well start with using R as a calculator, learn about naming and storing values/objects, then progress to loading and using data frames (the bread and butter of R in some sense), and finish with R Markdown documents, which allow you to create fully reproducible documents that contain a mixture of text and code. Fun fact: these notes were written in a collection of RMarkdown documents and compiled with a package called bookdown. As you proceed, we encourage you to try to run any code you see in this book and to play around and do things on your own. The best way to learn how to code is to experiment. The immediate feedback of running some successful code can be quite gratifying! 2.1 A big calculator At its most basic, R is a big, fancy, and initially cumbersome calculator. Think of any calculation youd like to do and R can likely do it. R can handle more than just numbers! For our purposes, well need numbers, strings, and logicals. 2.1.1 Numbers R has three atomic types of numbers: real, integer, and complex, but we will only need to think of real numbers. You can do arithmetic and evaluate the standard elementary functions with numbers as you would expect. Addition, multiplication, subtraction, and division are +, *, -, and / respectively. For example: 2 + 2 ## [1] 4 3 * 1.5 ## [1] 4.5 9 - 4 ## [1] 5 5/3 ## [1] 1.666667 Exponentiation is either ^ or **, the latter is old school. You can raise a number to a power of 10 using scientific notation, for example 1.2e4 is 12000. 2^3 ## [1] 8 2**3 ## [1] 8 1.2e4 ## [1] 12000 All of your favorite elementary functions are built into R. Note that the log function is base \\(e\\), not base 10. The example below shows how to change base. exp(2) # e^2 ## [1] 7.389056 sin(pi/2) # note the trig functions are in radians ## [1] 1 log(10) # natural log of 10 ## [1] 2.302585 log(100, 10) # the log of 100, base 10 ## [1] 2 Reminder! Be careful and mindful about the order of operations; computers and calculators read your input very literally. For instance, \\(6 \\div 2(1 + 2)\\), is an annoying statement with respect to the order of operations. R will evaluate this expression correctly if you type 6/2*(1+2). Make sure you can evaluate it correctly as well so that you input what you mean. 2.1.2 Strings We want to be able to analyze both numerical and categorical variables in R. For this reason, along with many others, your can use and manipulate strings of character in R. We wont be doing much more than using strings for values of categorical variables, so we wont go into too much detail. To define a string, simply put the expression in question in quotation marks. &quot;R might be cool? I don&#39;t know.&quot; Base R has some handy functions for manipulating strings. We may not need all of them, but theyre good to be aware of. substr(string, start=n1, stop=n2) will return a subset of your string starting at the n1th character, ending at the n2 character. substr(&quot;R might be cool? I don&#39;t know.&quot;, start = 18, stop = 30) ## [1] &quot;I don&#39;t know.&quot; nchar(string) counts the number of characters in a string. nchar(&quot;R might be cool? I don&#39;t know.&quot;) ## [1] 30 toupper/tolower(string) converts all letters to either upper or lower case. toupper(&quot;R might be cool? I don&#39;t know.&quot;) ## [1] &quot;R MIGHT BE COOL? I DON&#39;T KNOW.&quot; paste(..., sep = \" \") will concatenate a collection of strings, separated by a space. You can change what separates the strings. This function is most useful when you have to repeatedly concatenate some strings. paste(&quot;R might be cool? I don&#39;t know.&quot;, &quot;Yes, it is!&quot;) ## [1] &quot;R might be cool? I don&#39;t know. Yes, it is!&quot; You can do a lot more with strings, but things start to get more complicated quickly. The package stringr has some really handy functions, but are unnecessary for this course. 2.1.3 Logicals and Logical operators Throughout this class you will need to compare various objects in R using standard logical operators like equals (==), less than &lt;, greater than or equal to &gt;= etc. When you compare objects using these operators, R returns a new type of object called a logical. Logicals are just TRUE and FALSE. You can check equality of numbers and strings using ==. To check if two objects are unequal, use !=. 4 == 5 ## [1] FALSE 2^3 == 8 ## [1] TRUE &quot;cat&quot; == &quot;dog&quot; ## [1] FALSE &quot;dog&quot; != &quot;cat&quot; ## [1] TRUE You can compare numbers with your favorite inequalities (&lt;, &gt;, &lt;=, &gt;=) as well. More interestingly, you can also compare strings with inequalities. R defaults to lexicographic (ie dictionary) ordering of strings. 10 &lt; 9 ## [1] FALSE exp(3) &gt;= exp(2) ## [1] TRUE &quot;a&quot; &lt; &quot;b&quot; ## [1] TRUE &quot;aa&quot; &gt; &quot;ab&quot; ## [1] FALSE For convenience, TRUE sometimes behaves like 1 and FALSE like 0. In particular, you can perform arithmetic with logicals. This makes counting the number of matches you have quite easy in some situations, as well see. TRUE + TRUE ## [1] 2 TRUE*FALSE ## [1] 0 Note: R may occasionally exhibit behavior that you find goofy when comparing objects. This is usually because of coercion. When comparing objects, R will try to make the objects into the same type, if possible. We dont want to get bogged down in these details, but it is something to be aware of. The following example illustrates coercion when trying to compare a string to a number. &quot;1&quot; == 1 #R converts the string to 1, as a number, then compares. ## [1] TRUE &quot;01&quot; == 1 # R leaves the string as is, so the objects are unequal. ## [1] FALSE Finally, you can combine logical into compound expressions using the operators AND (in R AND is &amp;) and OR (in R |). The expression P &amp; Q is TRUE if and only if P and Q are both true. The expression P | Q yields TRUEif and only if at least one of P or Q is true. Lets look at some examples in code. (5 &gt; 2) &amp; (4 == 2^2) # both statements are true, so compound is as well ## [1] TRUE (5 &lt; 2) &amp; (4 == 2^2) # first statement false, so compound is false ## [1] FALSE (5 &lt; 2) | (4 == 2^2) # second statement is true, so compound is true ## [1] TRUE (5 &lt; 2) | (4 != 2^2) # both false, so compound is false ## [1] FALSE This might seem odd right now, but this simple feature is very helpful when identifying subsets of a dataset with certain properties as well see later on in these notes. 2.2 Naming things Now that we know what types of objects we can use in R, we can talk about naming objects and storing them in your computers memory so that you can reference them easily later. You can name objects in two ways, either with the classic &lt;- or with =. These two methods of naming objects technically do different things, but the difference is subtle enough that we wont worry about it. Note that when you name an object, it will appear in your Environment window in RStudio. The example below will illustrates the basics of naming objects. x &lt;- 1.123e6 y &lt;- 5 x ## [1] 1123000 y ## [1] 5 x/y ## [1] 224600 Once youve named an object and stored it in memory, you can use its name anywhere else to call the value associated to the name. Read the following only if youve had some programming experience. If not, skip to the next section. R makes copies of objects in a different way from, say, Python (and many other languages).The difference lies in deep vs shallow copies. Basically, a deep copy creates an entirely new object in memory, but a shallow copy merely points to the original objects position in memory. R will actually create a shallow copy until the original object is modified, then it will create a deep copy in order to save on memory. To illustrate this point, if you were to run the following code in Python: x = [1,2,3] y = x #shallow copy created here x.append(5) y it would print [1,2,3,5]. However, the equivalent code in R is x = 1:3 y = x # shallow copy of x created here x &lt;- append(x, 5) #but deep copy of original x created here for y y ## [1] 1 2 3 Its good to know how R is behaving; deep copies can end up using more memory, but that wont be an issue in this class with modern computing power. 2.3 Lists and vectors One of the many advantages to using a computer for mathematics, statistics, and data analysis is their ability to store and organize large chunks of information. A list/vector is the most basic way to start organizing data in R. This section will guide you through creating and manipulating lists. 2.3.1 Creating lists The most basic tool for creating a list in R is the function c(..). According to the documentation c(...) is a generic function which combines its arguments. All that to say that it is a function that creates a list. Heres a few examples. You can make lists with any types of data in them. x &lt;- c(1,2,3) y &lt;- c(&quot;cat&quot;, &quot;dog&quot;, &quot;rabbit&quot;) You can combine lists easily with the c(...) function as well, but notice in the example below that something funny happens. z &lt;- c(x, y) z ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;cat&quot; &quot;dog&quot; &quot;rabbit&quot; R coerced the numbers from the list x into characters/strings because y contains strings. This is a subtlety that can sometimes cause headaches. If your lists all contain the same types of objects, you have nothing to worry about. Throughout this course youll often want to know how many objects are in a list and most times we dont want to manually count them. The length function does this for us. The examples above are easy to count by hand, but as a quick check: length(x) ## [1] 3 length(y) ## [1] 3 length(z) ## [1] 6 2.3.2 Subsetting lists After defining a list, sometimes we want to access only certain elements of that list; this is called subsetting. Well spend more time on fancier subsetting methods later in this course, but this will get us started with the basics. Technical note: R indexing starts at 1 and not 0, a difference between R and some other programming languages like python. To get started, well create a long list of randomly generated numbers. rando &lt;- runif(1000, min = 0, max = 100) length(rando) ## [1] 1000 This list has 1000 elements in it. We can find the 497th element using rando[497] ## [1] 22.18519 and in general, use listName[number]. We can also easily select ranges of indicies. For instance, suppose we want to know what the first 10 values in our list are. rando[1:10] ## [1] 35.93569 74.11787 61.81160 96.36472 56.92292 71.14545 65.81920 ## [8] 71.35117 96.50238 73.98551 Finally, we can pick out specific elements from our big list using a smaller list of our desired indices. For example, if we wanted the entries number 2,3,5,7,11, and 13 from our list, we could use the following. indicies &lt;- c(2,3,5,7,11,13) rando[indicies] ## [1] 74.11787 61.81160 56.92292 65.81920 28.38549 49.17240 2.3.3 Special lists The last section taught us how to make the most basic type of list. While useful, making lists in this way can be tedious because it requires one to type in all values. Often out in the wild, you will want to create lists that follow specific patterns. For instance: the letters c through p; a list of the integers from 1 to 100; a list of numbers from -10 to 10, spaced by .01; the letters d, g, and z repeated 1000 times each. It is easy to construct these types of lists in R with minimal typing. Lists of integers: to make a list of sequential integers in R, use the format start : end, for instance 2:5 will return the list 2,3,4,5. x &lt;- -8:12 x ## [1] -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 length(x) ## [1] 21 Lists of sequential numbers that are not integers: The function seq produces sequences of numbers that follow a particular pattern. The general syntax is seq( from = STARTING VALUE, to = ENDING VALUE, by = SPACE BETWEEN ENTRIES) So if we wanted a list of all numbers from -10 to 10, spaced by .01, wed use foo &lt;- seq(from = -10, to = 10, by = .01) We can access the first 5 elements of this list and count the number of elements in our list foo with the following. foo[1:5] ## [1] -10.00 -9.99 -9.98 -9.97 -9.96 length(foo) ## [1] 2001 Lists of sequential letters: R has two in-built lists of letters called letters and LETTERS. No surprise, one of them is a list of lower case letters, the other upper case. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; To select the 4th through 11th lowercase letters of the alphabet, use the following syntax (which will be explained in a subsequent section). letters[4:11] ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; Lists with a repeating patterns: If youre performing an experiment or reformatting a data set, you may want to create a list with a repeated pattern. For example, suppose you have an experiment with 1000 people in the treatment group and 1000 people in the control group. The group a research subject is in is a variable, so should be a column in a data set. If the outcome of the experiment will be recorded in the order treatment, control, treatment, control, etc. for all 2000 participants, we would like to easily make a list of length 2000 following this pattern. The function rep( x, times = n) will do exactly this for us! In this case x is a list and times specifies the number of times youd like that list to be repeated. As an example, to make the list described above, we would use the commands vals &lt;- c( &quot;treatment&quot;, &quot;control&quot;) group &lt;- rep( vals, times = 1000 ) To ensure this does what we want, lets look at the length of group and at the first 10 elements. length(group) ## [1] 2000 group[1:10] ## [1] &quot;treatment&quot; &quot;control&quot; &quot;treatment&quot; &quot;control&quot; &quot;treatment&quot; ## [6] &quot;control&quot; &quot;treatment&quot; &quot;control&quot; &quot;treatment&quot; &quot;control&quot; Success! 2.3.4 List arithmetic Lists are great for storing information, but the real power comes from being able to manipulate them. You can weak lists in a few ways: using summary functions, which well cover in the next chapter, and using usual arithmetic. Lets start by defining 3 lists. x &lt;- 1:3 y &lt;- c(9, 18, 27) z &lt;- 10:15 #note length(z) = 6 Well start by adding, subtracting, multiplying, dividing lists, and exponentiate lists. We can also scale all values in a list by a constant and raise all elements to a certain power (note that R performs all of these operations component wise, so it may not be what youd expect if youve had some experience with matrices). x + y ## [1] 10 20 30 x - y ## [1] -8 -16 -24 x*y ## [1] 9 36 81 y/x ## [1] 9 9 9 y^x ## [1] 9 324 19683 .5*x ## [1] 0.5 1.0 1.5 x^2 ## [1] 1 4 9 Many functions in R are vectorized, meaning that if you input a list, the function will be applied to every element of the list. For example: sin(x) ## [1] 0.8414710 0.9092974 0.1411200 log(y, 3) #log base 3 ## [1] 2.00000 2.63093 3.00000 We need to be careful when doing arithmetic with lists. If were not careful, seemingly mysterious behavior can crop up if the lists were working with have different length. For instance, adding the lists x and z above doesnt seem to make sense since they have different lengths. But running the following returns a list with length 6. x + z ## [1] 11 13 15 14 16 18 So whats going on? R will repeat the values from the shorter list until the length matches the longer one. In the example above, were really getting the same result as rep(x, 2) + z ## [1] 11 13 15 14 16 18 This feature can be annoying and confusing if youre not aware of it, but helpful and powerful if you are. The next silly example will hopefully illustrate this point. Suppose we want to generate a list of random numbers such that the odd numbers are between -1 and 0, but the even numbers are between 1 and 2. Heres our strategy: first, generate 10 random numbers between 0 and 1; next, add one to all the even indexed entries so that their possible range of values goes from 0 to 1 to 1 to 2; finally, multiply the odd entries by -1. In code, this looks like rando &lt;- runif(10, min = 0, max = 1) rando &lt;- c(0,1) + rando rando &lt;- c(-1,1)*rando rando ## [1] -0.8781088 1.1268507 -0.5221108 1.1335155 -0.2741085 1.6709294 ## [7] -0.6137433 1.8464363 -0.1964737 1.6633337 A more practical application of this vectorization feature is to use logical operators and use them to help subset lists. As a basic example, R will compare lists component wise or to a particular value. x &lt; y ## [1] TRUE TRUE TRUE x &lt; 2 ## [1] TRUE FALSE FALSE Remember that we can combine logicals using &amp; and | (AND and OR). This gives us a way to check more complicated conditions on values. The list rando from above should have numbers between -1 and 0 in the odd entries and between 1 and 2 in the even. Lets check that. #subsetting only odd indices (rando &lt;= 0 &amp; rando &gt;= -1)[seq(from = 1, to = 10, by = 2)] ## [1] TRUE TRUE TRUE TRUE TRUE #subsetting only even indices (rando &gt;=1 &amp; rando &lt;= 2)[seq(from = 2, to = 10, by = 2)] ## [1] TRUE TRUE TRUE TRUE TRUE So the even and odd index entries of rando have the properties we wanted them to! Yahoo. Hopefully you are starting to see how these simple functions and features can be combined and layered into much more sophisticated gadgets. 2.4 Packages This short section changes gears. Recall that R and RStudio are both open-source projects, so much of the development lies in the hands of the community of users. There are many features and functions built into R, but youll occasionally run into things that are not innate to it. When this happens, you have two options: you can either program the feature that you want on your own (which is hard), or try to figure out if someone else has already programmed the feature youre interested in. Very often youll find that they have and typically these features will be available in an R package. Packages are simply extensions of the base R programming language; they typically contain code, data, and documentation. In this class, well use only a handful of packages. Some of them are: tidyverse: actually a collection of packages that utilize the same underlying syntax, grammar, etc. In principle, the tidyverse makes data science more intuitive, cleaner, and faster than base R. openintro: a package that contains many of the data sets in our textbook, OpenIntro Statistics. infer: a package that implements the tidyverse syntax and grammar for statistical inference. BDSA: a package that has a handful of data sets and a few functions that will be useful. This package is associated with the book Basic Statistics and Data Analysis by Larry J. Kitchens. There are thousands of R packages available to help you accomplish almost any task you can imagine. Some fun examples: spotifyr: a package to streamline accessing Spotifys API (application programming interface), so you can pull data on song, artist, and playlist information. There are similar packages for many of your favorite websites and applications. caret: a consolidated machine learning library that makes creating, analyzing, and utilizing machine learning algorithms a breeze. leaflet: a package for creating interactive maps in R. You have very likely interacted with a map created in leaflet! This link will show you some code to create a heatmap from Strava data using leaflet. bookdown: a package for authoring books in RStudio. The book you are reading was written using bookdown! You probably get the point: once you start using packages, the capabilities of R and RStudio are limitless. But how do you actually use them? First, you have to install the package, then load it into your current working environment. Installing packages: to install a package, use the function install.packages(...) in the console of RStudio. Be sure to put the name of the package in quotation marks. For example, to install the tidyverse package, execute the following code in the console: install.packages(&quot;tidyverse&quot;) Once youve install a package, you have to load and attach the package to your current working environment. Use the library(...) function to do this. After installing the package, you no longer need to call it with quotation marks. Thus, to attach the tidyverse package, execute the following in your Rstudio console: library(tidyverse) Caution 1: You have to attach the packages youd like to use every time you start a new RStudio session! Alternatively, you have to load them at the beginning of your R script or R Markdown document. More on this in a coming section. Caution 2: In RStudio Cloud, packages need to be installed in every project you create. This means if you start a new project for every activity, you must re-install (and of course load) all of the packages required for the project. To avoid this difficulty, I recommend starting one project for activities and creating a new folder in this project for each individual directory. 2.5 Data frames and tibbles Data frames are the bread and butter of R and statistics in general. At their most basic, they are simply arrays of objects be they numbers, strings, or logicals with named columns (and sometimes named rows). If youre recording data, remember: Each column of a data frame represents a variable. Each row of a data frame represents an observation, so you record a value of each variable for each observation. There are two primary types of data frames in R, data.frames and tibbles. The former is an object from base R and the latter is a data frame class from the tidyverse package. There are differences between these two classes of data frames, but we wont worry about them too much. In this class, because they display in a nicer way and some operations are performed more quickly with them, we will primarily use tibbles. For more information on tibble vs data.frame, evaluate ?tibble in the console after loading the tidyverse package. 2.5.1 Creating data frames 2.5.1.1 From packages Many R packages contain test data sets that can be stored in your computers memory and used for exploration and demonstration of particular ideas. To use these data sets, you can either make a copy of them using the &lt;- operator or load them using the data function. As an example, tidyverse has a dataset labeled us_rent_income. You can load use this data set by calling df &lt;- us_rent_income #or data(&quot;us_rent_income&quot;) #note the quotation marks! These built-in data sets are great for examples, but they dont help you analyze your own data. Next, well learn how to input our own data into R. 2.5.1.2 Reading files The most common way to load your own data into R is by reading the data in from a file (eg csv, excel, pdf, etc files) stored on your computer. These other file formats are much easier and more flexible for entering data. Loading and analyzing the data in R also helps prevent the user from accidentally changing values in their data during their analysis; changing values in data sets in R is very difficult to do accidentally by design). We cant and wont try to cover all of the possible ways you can load a data set into R from a file on your computer, but we will cover some of the most common techniques. In general, you can figure out how to load a file of a particular type into R with a simple internet search. Below we list some functions and their use. In each case, the first input is file, which is possibly a the path of the file youre trying to load. Its easiest to put the file in the same directory/folder that youre working in. read.csv(file, ...): this function reads a CSV (comma separated value) file and loads the data into R. Note that sometimes you have to tweak the arguments of this function to load the data set in exactly the way you want. read_excel(file, ...): from the readxl package does what youd expect, reading and loading Microsoft Excel files. As above, you might have to play around with this to load the data appropriately. pdf_text(file, ...): from the pdftools reads all of the text from each page of a PDF document. This is handy, but requires quite a bit of tidying and is not something well cover in this course. The basic take away is that you can read data from PDF files into R. download.file(url, destfile, ...): this function downloads a file from from the specified url and stores it as destfile. The following example illustrates how you might use a combination of these functions in practice. The code downloads a data set from Montana State Universitys STAT216 GitHub page, loads it into R, then displays the results. The data set lists a handful of countries, the countrys max speed limit, and the average number of highway fatalities annually. #first we store the url and file name as strings url &lt;- &quot;https://raw.githubusercontent.com/MTstateIntroStats/IntroStatActivities/master/data/Highway.csv&quot; fileName &lt;- &quot;Highway.csv&quot; #the next command downloads the file if you haven&#39;t downloaded it already if(!file.exists(fileName)){ download.file(url, fileName) } #now load the file into R df &lt;- read.csv(fileName) #print data frame df ## limit death country ## 1 55 3.0 Norway ## 2 55 3.3 United States ## 3 55 3.4 Finland ## 4 70 3.5 Britain ## 5 55 4.1 Denmark ## 6 60 4.3 Canada ## 7 55 4.7 Japan ## 8 60 4.9 Australia ## 9 60 5.1 Netherlands ## 10 75 6.1 Italy 2.5.1.3 Manual entry When you are simulating data, working on homework, or simply have a small data set, it can be convenient to manually type your data into R. To make a data frame, you simply list the columns as named vectors. We will go through three examples of of how you can do this. First off, suppose you wanted to enter the following table as a data frame into R. animal weight length cat 5 24 dog 45 35 rabbit 2 10 turtle 15 15 To enter this table, we would use the following: df &lt;- tibble( animal = c(&quot;cat&quot;, &quot;dog&quot;, &quot;rabbit&quot;, &quot;turtle&quot;), weight = c(5, 45, 2, 15), length = c(24, 35, 10, 15)) df ## # A tibble: 4 x 3 ## animal weight length ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 cat 5 24 ## 2 dog 45 35 ## 3 rabbit 2 10 ## 4 turtle 15 15 Now suppose we want to make a data set for the points on the line \\(y = 2x + 3 + \\text{some random noise}\\) with integer \\(x\\) values between 1 and 10. We can do this easily! df &lt;- tibble(x = 1:10, y = 2*x + 3 + rnorm(10)) df ## # A tibble: 10 x 2 ## x y ## &lt;int&gt; &lt;dbl&gt; ## 1 1 5.75 ## 2 2 8.48 ## 3 3 11.3 ## 4 4 10.0 ## 5 5 14.2 ## 6 6 15.8 ## 7 7 17.5 ## 8 8 17.3 ## 9 9 21.1 ## 10 10 22.3 As a final example, lets start with a table that doesnt follow the convention of variables in columns, observations in rows. For this example, suppose you recorded the weight in pounds of 5 turtles, cats, and dogs as follows: Turtle Cat Dog 15 2 26 10 13 60 15 12 60 12 8 22 12 2 59 In this case, notice that we only actually have two variables around, not three: species of pet and pet weight. When dealing with categorical variables, it is common to see data organized as above, but be aware that this isnt the most effective way to organize your information for the purpose of analysis. Since the data set has only two variables, our data frame in R should only have two columns. We could enter this data as follows: df &lt;- tibble( species = c( rep(&quot;turtle&quot;, 5), rep(&quot;cat&quot;, 5), rep(&quot;dog&quot;, 5)), weight = c(15, 10, 15, 12, 12,2, 13, 12, 8 , 2,26, 60, 60, 22, 59)) df ## # A tibble: 15 x 2 ## species weight ## &lt;chr&gt; &lt;dbl&gt; ## 1 turtle 15 ## 2 turtle 10 ## 3 turtle 15 ## 4 turtle 12 ## 5 turtle 12 ## 6 cat 2 ## 7 cat 13 ## 8 cat 12 ## 9 cat 8 ## 10 cat 2 ## 11 dog 26 ## 12 dog 60 ## 13 dog 60 ## 14 dog 22 ## 15 dog 59 This format might not be as easy to see, but it will be substantially easier to analyze in R. 2.5.2 Using data frames You can think of the rest of this book as a quick summary on ways to use data frames, but this section will touch on a few basics we need before we can do anything else. In this section, well use the starwars data set from the tidyverse package. First off, once youve stored a data set, it is good to look at it to see what youre working with. There are a few different options that all have their places. view(df): from the tidyverse package and opens a spreadsheet-like view of your dataset. You cannot edit the data, only see it. head(df): returns the first 6 rows of a data set and may exclude some columns from view. tail(df): returns the last 6 rows of a data set and may exclude some of the columns from view. glimpse(df): from the tidyverse package and prints a few entries from every column of your data set. Lets see how all of these (except view) behave on the starwars data set. Try view(starwars) out on your own. head(starwars) ## # A tibble: 6 x 14 ## name height mass hair_color skin_color eye_color birth_year sex ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Luke Skywa~ 172 77 blond fair blue 19 male ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none ## 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none ## 4 Darth Vader 202 136 none white yellow 41.9 male ## 5 Leia Organa 150 49 brown light brown 19 fema~ ## 6 Owen Lars 178 120 brown, gr~ light blue 52 male ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; tail(starwars) ## # A tibble: 6 x 14 ## name height mass hair_color skin_color eye_color birth_year sex ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Finn NA NA black dark dark NA male ## 2 Rey NA NA brown light hazel NA fema~ ## 3 Poe Dameron NA NA brown light brown NA male ## 4 BB8 NA NA none none black NA none ## 5 Captain Ph~ NA NA unknown unknown unknown NA &lt;NA&gt; ## 6 Padmé Amid~ 165 45 brown light brown 46 fema~ ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; glimpse(starwars) ## Rows: 87 ## Columns: 14 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, &quot;Le~ ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, 1~ ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.0~ ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;brow~ ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;ligh~ ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;, &quot;b~ ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, 5~ ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;none&quot;, &quot;none&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;fem~ ## $ gender &lt;chr&gt; &quot;masculine&quot;, &quot;masculine&quot;, &quot;masculine&quot;, &quot;masculine&quot;, &quot;f~ ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alderaan~ ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human&quot;, ~ ## $ films &lt;list&gt; &lt;&quot;The Empire Strikes Back&quot;, &quot;Revenge of the Sith&quot;, &quot;R~ ## $ vehicles &lt;list&gt; &lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;,~ ## $ starships &lt;list&gt; &lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Advanced~ IMPORTANT! Now that weve looked at our data, we might want to access certain columns in that data frame; this is what the $ operator does in R. Explicitly, df$columnName yields the column with name columnName as a list, as in the example below. Were using the head function because the list of characters is long. length(starwars$name) ## [1] 87 head( starwars$name ) ## [1] &quot;Luke Skywalker&quot; &quot;C-3PO&quot; &quot;R2-D2&quot; &quot;Darth Vader&quot; ## [5] &quot;Leia Organa&quot; &quot;Owen Lars&quot; Just as with lists, you can pick out particular elements or ranges of elements in a data frame using bracket notation. In general, the syntax is df[rowRange , columnRange] where rowRange and columnRange can be lists or single numbers. Using starwars as an example: starwars[2, 5] #second row, 5th column ## # A tibble: 1 x 1 ## skin_color ## &lt;chr&gt; ## 1 gold starwars[2,] #all columns and only second row ## # A tibble: 1 x 14 ## name height mass hair_color skin_color eye_color birth_year sex ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; head(starwars[,5]) #head of 5th column ## # A tibble: 6 x 1 ## skin_color ## &lt;chr&gt; ## 1 fair ## 2 gold ## 3 white, blue ## 4 white ## 5 light ## 6 light We close this section with a discussion on the subset function, which allows one to select certain rows from a data set that have some desired features. The function returns a data set with all of the same columns as the original. The syntax is subset(data, condition on variables). As an example, suppose we wanted a data set of all Star Wars characters whose mass is less than 45 kilograms. smallCharacters &lt;- subset(starwars, mass &lt; 45) Since we reference the data set starwars inside the call to subset we dont need to call the mass column with a $. 2.6 R Markdown documents In this course you will complete a handful of activities using RStudio. Youll write up the results of these activities as lab reports in R Markdown documents. Markdown is an easy-to-learn markup language that converts a plain-text file into a nicely formatted document. R Markdown documents provide an interface between R and Markdown. In a markdown document, you can write R code along with markdown text. When you compile your R Markdown document, RStudio evaluates all code and prints the output. In this way, R Markdown provides a way to create fully reproducible data analysis reports and more (this book was written in R Markdown!). You can use Rmd documents to save and execute code in a notebook style environment and create beautiful reports. A lot of people have already written quite a bit about R Markdown, so well keep this brief. For more detailed information, check out this tutorial provided by RStudio. To play around, start with the following: Create a new Rmd file by clicking file -&gt; new file -&gt; R Markdown. Enter a title, your name, and the date, then click OK. This creates a new Rmd file. A document should open that looks like this. An R Markdown document Notice that your document has three different types of environments. The YAML is at the beginning and delineated by --- at the beginning and end. This section determines the overall formatting of your document. You can go wild in this section with some guidance and internet sleuthing. Code chunks which start with ```{r} and end with ```. Code chunks allow you to use R in a notebook-style environment by clicking the green triangle in the upper right-hand corner of the chunk to run the code. You can run any code you can imagine in a code chunk. Plain text and text formatted using markdown. Write whatever you want. Headings are indicated by pound signs, with the size of the heading determined by the number of pound signs, so # Title would be a big title, ## Section would be a section heading, a ### Subsection, and so on. You can make text italic by surrounding the text with * on both sides. You can bold face text with **. For example *foo* renders as foo and **bar** renders as bar. There are a lot more formatting hacks, but that should get you started. As youre writing a document, you should periodically knit the document Knitting starts at the beginning of your document and evaluates it from top to bottom, then renders the output in whatever format youve specified. RStudio executes code chunks in sequential order. RStudio ignores all values and data stored in memory and all loaded packages when knitting. In this way, knitting a document starts a new environment from scratch. This feature can lead to headaches if you dont think about it ahead of time. Some common pitfalls when using R Markdown: forgetting to load packages at the beginning of a document and loading them from the console. In this case, all code chunks will run, but your document may not knit. Notice that I included a few packages in the screenshot above Dont forget to load packages at the beginning! naming an object from the console (eg: x &lt;- 1:10) and using it in a code chunk, but forgetting to name the same object in a code chunk. In this case, code chunks will all evaluate, but your document will not knit. Some suggestions when using R Markdown: run your code chunks often. This helps ensure everything is working the way you think it should. knit your document early and often. It is a lot easier to find small mistakes as they arise than it is to debug an entire document. be patient. R Markdown is a powerful tool and you can do a lot with it, but it can take a little bit of getting used to. You can use it to do a lot more than write lap reports. For instance, you may be able to write a scientific paper in R Markdown and have all of your writing and data analysis in one package! Try new things; it is really easy to write code that doesnt run, but it is really hard to break R, RStudio, or a Markdown document. You can only improve by trying. If you want to take a deep dive into markdown, check out the book R Markdown: The Definitive Guide. "],["cross.html", "Chapter 3 Summary statistics and data visualization 3.1 Summary statistics in R 3.2 Data visualization", " Chapter 3 Summary statistics and data visualization TODO 3.1 Summary statistics in R 3.2 Data visualization There are three main ways to create plots in R: base R, lattice, and ggplot2. We will only learn about base R and ggplot2 in this course. In practice, I use base R to make graphs quickly to get an idea of whats going on and ggplot2 to make more visually appealing and complicated graphics. 3.2.1 Base R 3.2.2 ggplot2 "],["wrangling-data.html", "Chapter 4 Wrangling data", " Chapter 4 Wrangling data TODO "],["distribution-calculations.html", "Chapter 5 Distribution calculations", " Chapter 5 Distribution calculations TO DO: describe how to make distribution calcs "],["inferential-statistics-take-1.html", "Chapter 6 Inferential statistics, take 1", " Chapter 6 Inferential statistics, take 1 TO DO: basically calculations by hand "],["inferential-statistics-take-2.html", "Chapter 7 Inferential statistics, take 2 7.1 Analyzing categorical variables 7.2 Analyzing numerical variables", " Chapter 7 Inferential statistics, take 2 TO DO: hypothesis testing and confidence intervals using in-built functions in R. 7.1 Analyzing categorical variables 7.1.1 Single sample 7.1.2 Two sample 7.1.3 Chi-squared goodness of fit test 7.1.4 Chi-squared test of independence 7.2 Analyzing numerical variables 7.2.1 Single sample mean 7.2.2 Two sample mean 7.2.3 Paired data 7.2.4 Analysis of variance (ANOVA) "],["references.html", "References", " References "],["modeling-relationships.html", "Chapter 8 Modeling relationships 8.1 Simple linear regression 8.2 Multiple linear regression 8.3 Bonus topic: logistic regression", " Chapter 8 Modeling relationships To do 8.1 Simple linear regression 8.2 Multiple linear regression 8.3 Bonus topic: logistic regression "]]
